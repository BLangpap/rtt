#ifndef ORO_CORBA_DATAFLOW_IDL
#define ORO_CORBA_DATAFLOW_IDL

#ifdef CORBA_IS_TAO
//resolves LNK2005
#include <tao/orb.idl>
#endif
#include "Operations.idl"

module RTT
{
  module corba
  {
    enum CFlowStatus { CNoData, CNewData, COldData };
    enum CConnectionModel { CData, CBuffer };
    enum CLockPolicy { CLocked, CLockFree };
    struct CConnPolicy
    {
        CConnectionModel type;
        boolean init;
        CLockPolicy lock_policy;
        boolean pull;
        long size;
        long transport;
        long data_size;
        string name_id;
    };

    interface CChannelElement
    {
        void setRemoteSide(in CChannelElement writer);
        CFlowStatus read(out any sample);
        boolean write(in any sample);
        boolean remoteSignal();
        /**
         * Used during connection setup to pass on
         * an example of the data.
         * This is done behind the scenes by the connection logic.
         */
        //boolean setDataSample(in any sample);
        /**
         * Called by the input port to indicate that
         * it's ready to be used.
         * This is done behind the scenes by the connection logic.
         */
        //boolean inputReady();
        void remoteDisconnect(in boolean writer_to_reader);
    };

    /** Emitted when information is requested on a port that does not exist */
    exception CNoSuchPortException {};
    /** Emitted during connections, when there is no CORBA transport defined
     * for the data type of the given ports
     */
    exception CNoCorbaTransport {};

    enum CPortType { CInput, COutput };

    struct CPortDescription
    {
        CPortType type;
        string   name;
        string   type_name;
    };

    /**
     * An interface to access the dataflow
     * of a CControlTask object. Data ports are exported as
     * assignable expressions (Set/Get). Buffer ports are
     * exported as buffer channels.
     * @ingroup CompIDL
     */
    interface CDataFlowInterface
    {
      typedef sequence<string> CPortNames;
      typedef sequence<CPortDescription> CPortDescriptions;

      /**
       * Returns the names of the ports of this component.
       */
      CPortNames getPorts();

      /**
       * Returns the names of the ports of this component.
       */
      CPortDescriptions getPortDescriptions();

      /**
       * Returns the type of the given port
       */
      CPortType getPortType(in string port_name)
            raises(CNoSuchPortException);

      /**
       * Returns the data type for the given port
       */
      string getDataType(in string port_name)
            raises(CNoSuchPortException);

      /**
       * Check if the given port is already connected to something
       */
      boolean isConnected(in string port_name)
            raises(CNoSuchPortException);

      /**
       * Disconnects this port from all connections it is part of
       */
      void disconnect(in string port_name)
            raises(CNoSuchPortException);

      /** 
       * Removes the specified connection
       */
      void disconnectPort(in string writer_name,
            in CDataFlowInterface reader_iface, in string reader_name);

      /**
       * Creates the reader-half of the connection for the given read port and
       * the given policy.
       * Some protocols may adjust the policy, or pass additional information
       * into the policy, such as the name of the newly created connection.
       */
      CChannelElement buildOutputHalf(in string port, inout CConnPolicy policy)
            raises(CNoCorbaTransport);

      /**
       * Connect the given named port to the given remote port
       *
       * The local port needs to be the reader, while the remote port is the
       * writer
       */
      boolean createConnection(in string local_port, in CDataFlowInterface remote_ports,
            in string remote_port, in CConnPolicy policy)
            raises(CNoSuchPortException);
            
      /**
       * Checks if the connection channel elements are ready for a given
       * input port.
       * This is typically called by the connection setup logic to see
       * if the input side agrees with the connection and can use it.
       * @return false if the connection could not be used.
       */
      boolean channelsReady(in string input_port);
    };
  };
};
#endif

