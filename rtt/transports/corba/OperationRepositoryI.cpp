// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// ../../../ACE_wrappers/TAO/TAO_IDL/be/be_codegen.cpp:1196

#include "CorbaLib.hpp"
#include "CorbaTypeTransporter.hpp"
#include "OperationRepositoryI.h"
#include "AnyDataSource.hpp"
#include "../../rtt-detail-fwd.hpp"
#include "../../internal/MethodC.hpp"

using namespace RTT;
using namespace RTT::detail;
using namespace std;

// Implementation skeleton constructor
RTT_corba_CSendHandle_i::RTT_corba_CSendHandle_i (void)
{
}

// Implementation skeleton destructor
RTT_corba_CSendHandle_i::~RTT_corba_CSendHandle_i (void)
{
}

::RTT::corba::CSendStatus RTT_corba_CSendHandle_i::collect (
    ::RTT::corba::CAnyArguments & args)
{
  // Add your implementation here
}

::RTT::corba::CSendStatus RTT_corba_CSendHandle_i::collectIfDone (
    ::RTT::corba::CAnyArguments & args)
{
  // Add your implementation here
}

::RTT::corba::CSendStatus RTT_corba_CSendHandle_i::checkStatus (
    void)
{
  // Add your implementation here
}

::CORBA::Any * RTT_corba_CSendHandle_i::ret (
    void)
{
  // Add your implementation here
}

// Implementation skeleton constructor
RTT_corba_COperationRepository_i::RTT_corba_COperationRepository_i (OperationRepository* gmf, PortableServer::POA_ptr the_poa)
    :mfact(gmf), mpoa( PortableServer::POA::_duplicate(the_poa))
{
}

PortableServer::POA_ptr RTT_corba_COperationRepository_i::_default_POA()
{
    return PortableServer::POA::_duplicate(mpoa);
}


// Implementation skeleton destructor
RTT_corba_COperationRepository_i::~RTT_corba_COperationRepository_i (void)
{
}

::RTT::corba::COperationRepository::COperationList * RTT_corba_COperationRepository_i::getOperations (
    void)
{
    RTT::corba::COperationRepository::COperationList_var rlist = new RTT::corba::COperationRepository::COperationList();

    vector<string> flist = mfact->getNames();
    rlist->length( flist.size() );
    for (size_t i=0; i != flist.size(); ++i)
        rlist[i] = CORBA::string_dup( flist[i].c_str() );
    return rlist._retn();
}

::RTT::corba::CDescriptions * RTT_corba_COperationRepository_i::getArguments (
    const char * operation)
{
    CDescriptions_var ret = new CDescriptions();
    if ( mfact->hasMember( string( operation ) ) == false )
        throw ::RTT::corba::CNoSuchNameException( operation );
    // operation found, convert args:
    OperationRepository::Descriptions args = mfact->getArgumentList( string(operation) );
    ret->length( args.size() );
    for (size_t i =0; i != args.size(); ++i) {
        ret[i].name = CORBA::string_dup( args[i].name.c_str() );
        ret[i].description = CORBA::string_dup( args[i].description.c_str() );
        ret[i].type = CORBA::string_dup( args[i].type.c_str() );
    }
    return ret._retn();
}

char * RTT_corba_COperationRepository_i::getResultType (
    const char * operation)
{
    if ( mfact->hasMember( string( operation ) ) == false )
        throw ::RTT::corba::CNoSuchNameException( operation );
    return CORBA::string_dup( mfact->getResultType( string(operation) ).c_str() );
}

char* RTT_corba_COperationRepository_i::getArgumentType(
        const char* operation,
        CORBA::UShort nbr)
{
    if ( mfact->hasMember( string( operation ) ) == false )
        throw ::RTT::corba::CNoSuchNameException( operation );
    if ( nbr > mfact->getPart(operation)->arity() )
        throw ::RTT::corba::CWrongArgumentException( nbr, mfact->getPart(operation)->arity() );
    return CORBA::string_dup( mfact->getPart( operation )->getArgumentType(nbr)->getTypeName().c_str() );
}

char* RTT_corba_COperationRepository_i::getCollectType(
        const char* operation,
        CORBA::UShort nbr)
{
    if ( mfact->hasMember( string( operation ) ) == false )
        throw ::RTT::corba::CNoSuchNameException( operation );
    if ( nbr > mfact->getPart(operation)->collectArity() )
        throw ::RTT::corba::CWrongArgumentException( nbr, mfact->getPart(operation)->collectArity() );
    return CORBA::string_dup( mfact->getPart( operation )->getCollectType(nbr)->getTypeName().c_str() );

}


char * RTT_corba_COperationRepository_i::getDescription (
    const char * operation)
{
    if ( mfact->hasMember( string( operation ) ) == false )
        throw ::RTT::corba::CNoSuchNameException( operation );
    return CORBA::string_dup( mfact->getDescription( string(operation) ).c_str() );
}

void RTT_corba_COperationRepository_i::checkOperation (
    const char * operation,
    ::RTT::corba::CAnyArguments & args)
{
  // Add your implementation here
}

::CORBA::Any * RTT_corba_COperationRepository_i::callOperation (
    const char * operation,
    ::RTT::corba::CAnyArguments & args)
{
    if ( mfact->hasMember( string( operation ) ) == false )
        throw ::RTT::corba::CNoSuchNameException( operation );
    // convert Corba args to C++ args.
    try {
        MethodC orig(mfact->getPart(operation), operation, 0);
        for (size_t i =0; i != args.length(); ++i) {
            const TypeInfo* ti = mfact->getPart(operation)->getArgumentType( i + 1);
            if (ti) {
                CorbaTypeTransporter* ctt = dynamic_cast<CorbaTypeTransporter*> ( ti->getProtocol(ORO_CORBA_PROTOCOL_ID) );
                orig.arg( ctt->createDataSource( &args[i] ));
            } else {
                // this will cause failure, but will print a nice wrong type/number of arg exception later on.
                orig.arg( new AnyDataSource( new CORBA::Any( args[i] ) ) );
            }
        }
        if ( orig.ready() ) {
            DataSourceBase::shared_ptr ds = orig.getCallDataSource();
            // Call nomatter what:
            ds->evaluate();
            // Try to return result:
            const TypeInfo* ti = ds->getTypeInfo();
            CorbaTypeTransporter* ctt = dynamic_cast<CorbaTypeTransporter*> ( ti->getProtocol(ORO_CORBA_PROTOCOL_ID) );
            if ( !ctt ) {
                log(Warning) << "Could not return results of call to " << operation << ": unknown return type by CORBA transport."<<endlog();
                return new CORBA::Any();
            }
            return ctt->createAny( ds );
        } else {
            orig.check(); // will throw
        }
    } catch ( name_not_found_exception& nnf ) {
        throw ::RTT::corba::CNoSuchNameException( operation );
    } catch ( wrong_number_of_args_exception& wna ) {
        throw ::RTT::corba::CWrongNumbArgException( wna.wanted, wna.received );
    } catch (wrong_types_of_args_exception& wta ) {
        throw ::RTT::corba::CWrongTypeArgException( wta.whicharg, wta.expected_.c_str(), wta.received_.c_str() );
    }
    return new ::CORBA::Any();
}

::RTT::corba::CSendHandle_ptr RTT_corba_COperationRepository_i::sendOperation (
    const char * operation,
    ::RTT::corba::CAnyArguments & args)
{
  // Add your implementation here
    assert(false);
}


