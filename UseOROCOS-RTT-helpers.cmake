#
# Parses the manifest.xml file and stores the dependencies in RESULT.
# Relies on xpath. If no manifest is found, returns an empty RESULT.
#
# Usage: orocos_get_manifest_deps DEPS)
#
function( orocos_get_manifest_deps RESULT)
  if ( NOT EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/manifest.xml )
     message("Note: this package has no manifest.xml file. No dependencies can be auto-configured.")
     return()
  endif ( NOT EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/manifest.xml )

  find_program(XPATH_EXE xpath )
  if (NOT XPATH_EXE)
    message("Warning: xpath not found. Can't read dependencies in manifest.xml file.")
  else(NOT XPATH_EXE)
    IF (APPLE)
      execute_process(COMMAND ${XPATH_EXE} ${CMAKE_CURRENT_SOURCE_DIR}/manifest.xml "package/depend/@package" RESULT_VARIABLE RES OUTPUT_VARIABLE DEPS)
      SET(REGEX_STR " package=\"([^\"]+)\"")
    ELSE (APPLE)
      execute_process(COMMAND ${XPATH_EXE} -q -e "package/depend/@package" ${CMAKE_CURRENT_SOURCE_DIR}/manifest.xml RESULT_VARIABLE RES OUTPUT_VARIABLE DEPS)
      SET(REGEX_STR " package=\"([^\"]+)\"\n")
    ENDIF (APPLE)
    if (NOT RES EQUAL 0)
      message(SEND_ERROR "Error: xpath found but returned non-zero:${DEPS}")
    endif (NOT RES EQUAL 0)

    string(REGEX REPLACE "${REGEX_STR}" "\\1;" RR_RESULT ${DEPS})

    #message("Deps are: '${DEPS}'")
    #message("Dependencies are: '${RR_RESULT}'")
    set(${RESULT} ${RR_RESULT})
  endif (NOT XPATH_EXE)

endfunction( orocos_get_manifest_deps RESULT)

#
# Find a package, pick up its include dirs and link with its libraries.
# It does this by locating and reading the .pc file generated by that package.
# In case no such .pc file exists (or is not found), tt is assumed that no
# flags are necessary.
#
# This macro is called for you by UseOrocos-RTT.cmake
# for each dependency listed in your manifest.xml file. 
#
# sets these variables:
# ${PACKAGE}_LIBRARIES            The fully resolved link libraries for this package.
# ${PACKAGE}_INCLUDE_DIRS         The include directories for this package.
# ${PACKAGE}_LIBRARY_DIRS         The library directories for this package.
# ${PACKAGE}_CFLAGS_OTHER         The compile flags other than -I for this package.
# ${PACKAGE}_LDFLAGS_OTHER        The linker flags other than -L and -l for thfully resolved link libraries for this package.
# ${PACKAGE}_<LIB>_LIBRARY        Each fully resolved link library <LIB> in the above list.
#
# USE_OROCOS_COMPILE_FLAGS        All exported compile flags from packages within the current scope.
# USE_OROCOS_LINK_FLAGS           All exported link flags from packages within the current scope.
#
#
# Usage: orocos_use_package( myrobot )
#
macro( orocos_use_package PACKAGE )
  if (PACKAGE STREQUAL "rtt")
    return()
  endif (PACKAGE STREQUAL "rtt")
  if (IS_ROS_PACKAGE)
    if (NOT USE_FOUND_${PACKAGE}_PACKAGE_PATH)
      # use rospack to find package directories of *all* dependencies.
      # We need these because a .pc file may depend on another .pc file in another package.
      # This package + the packages this package depends on:
      rosbuild_find_ros_package(${PACKAGE})
      if (${PACKAGE}_PACKAGE_PATH)
        rosbuild_invoke_rospack(${PACKAGE} ${PACKAGE}_prefix DEPS depends)
        string(REGEX REPLACE "\n" ";" ${PACKAGE}_prefix_DEPS2 "${${PACKAGE}_prefix_DEPS}" )
        foreach(ROSDEP ${${PACKAGE}_prefix_DEPS2} ${PACKAGE})
          # Skip previously found packages
          if (NOT USE_FOUND_${ROSDEP}_PACKAGE_PATH)
            rosbuild_find_ros_package( ${ROSDEP} )
	    # We prefer looking in the install directory above the package's own directory:
            set( ENV{PKG_CONFIG_PATH} "${${ROSDEP}_PACKAGE_PATH}/install/lib/pkgconfig:${${ROSDEP}_PACKAGE_PATH}:$ENV{PKG_CONFIG_PATH}" )
            set( USE_FOUND_${ROSDEP}_PACKAGE_PATH 1 ) # mark we don't need to find it again.
          endif (NOT USE_FOUND_${ROSDEP}_PACKAGE_PATH)
        endforeach(ROSDEP ${${PACKAGE}_prefix_DEPS2} ${PACKAGE})
      endif (${PACKAGE}_PACKAGE_PATH)

      #message("Searching for ${PACKAGE} in ${${ROSDEP}_PACKAGE_PATH}.")
    else (NOT USE_FOUND_${PACKAGE}_PACKAGE_PATH)
      if (VERBOSE)
	message("[UseOrocos] Note: '${PACKAGE}' is not a ROS package. Trying .pc file...")
      endif (VERBOSE)
    endif (NOT USE_FOUND_${PACKAGE}_PACKAGE_PATH)
  else(IS_ROS_PACKAGE)
    #Use default pkg-config path
    #message("Searching for ${PACKAGE} in env PKG_CONFIG_PATH.")
  endif(IS_ROS_PACKAGE)

  # Now we are ready to get the flags from the .pc files:
  #pkg_check_modules(${PACKAGE}_COMP ${PACKAGE}-${OROCOS_TARGET})
  pkg_search_module(${PACKAGE}_COMP_${OROCOS_TARGET} ${PACKAGE} ${PACKAGE}-${OROCOS_TARGET})
  if (${PACKAGE}_COMP_${OROCOS_TARGET}_FOUND)
    include_directories(${${PACKAGE}_COMP_${OROCOS_TARGET}_INCLUDE_DIRS})

    # Use find_libraries to find each library:
    unset(${PACKAGE}_LIBRARIES CACHE)
    foreach(COMP_LIB ${${PACKAGE}_COMP_${OROCOS_TARGET}_LIBRARIES})
        # Two options: COMP_LIB is an absolute path-to-lib (must start with ':') or just a libname:
        if ( ${COMP_LIB} MATCHES "^:(.+)")
	  if (EXISTS "${CMAKE_MATCH_1}" )
            # absolute path:
            set( ${PACKAGE}_${COMP_LIB}_LIBRARY "${CMAKE_MATCH_1}" )
	  endif()
        else()
           # libname:
          find_library(${PACKAGE}_${COMP_LIB}_LIBRARY NAMES ${COMP_LIB} HINTS ${${PACKAGE}_COMP_${OROCOS_TARGET}_LIBRARY_DIRS})
        endif()
        if(${PACKAGE}_${COMP_LIB}_LIBRARY)
        else(${PACKAGE}_${COMP_LIB}_LIBRARY)
            message(SEND_ERROR "In package >>>${PACKAGE}<<< : could not find library ${COMP_LIB} in directory ${${PACKAGE}_COMP_${OROCOS_TARGET}_LIBRARY_DIRS}, although its .pc file says it should be there.\n\n Try to do 'make clean; rm -rf lib' and then 'make' in the package >>>${PACKAGE}<<<.\n\n")
        endif(${PACKAGE}_${COMP_LIB}_LIBRARY)
        list(APPEND ${PACKAGE}_LIBRARIES "${${PACKAGE}_${COMP_LIB}_LIBRARY}")
    endforeach(COMP_LIB ${${PACKAGE}_COMP_${OROCOS_TARGET}_LIBRARIES})

    # Add some output variables to the cache to make them accessible from outside this scope
    set(${PACKAGE}_INCLUDE_DIRS "${${PACKAGE}_COMP_${OROCOS_TARGET}_INCLUDE_DIRS}" CACHE INTERNAL "")
    set(${PACKAGE}_LIBRARY_DIRS "${${PACKAGE}_COMP_${OROCOS_TARGET}_LIBRARY_DIRS}" CACHE INTERNAL "")
    set(${PACKAGE}_LIBRARIES "${${PACKAGE}_LIBRARIES}" CACHE INTERNAL "")
    # The flags are space separated, so no need to quote here:
    set(${PACKAGE}_CFLAGS_OTHER ${${PACKAGE}_COMP_${OROCOS_TARGET}_CFLAGS_OTHER} CACHE INTERNAL "")
    set(${PACKAGE}_LDFLAGS_OTHER ${${PACKAGE}_COMP_${OROCOS_TARGET}_LDFLAGS_OTHER} CACHE INTERNAL "")

    # Add compiler and linker flags to the USE_OROCOS_XXX_FLAGS variables used in the orocos_add_x macros
    set(USE_OROCOS_COMPILE_FLAGS ${USE_OROCOS_COMPILE_FLAGS} ${${PACKAGE}_COMP_${OROCOS_TARGET}_CFLAGS_OTHER})
    set(USE_OROCOS_LINK_FLAGS ${USE_OROCOS_LINK_FLAGS} ${${PACKAGE}_COMP_${OROCOS_TARGET}_LDFLAGS_OTHER})
    # This probably does not work since lists are ';' separated and not ' ' separated:
    list(REMOVE_DUPLICATES USE_OROCOS_COMPILE_FLAGS)
    list(REMOVE_DUPLICATES USE_OROCOS_LINK_FLAGS)

    # Only link in case there is something *and* the user didn't opt-out:
    if (NOT OROCOS_NO_AUTO_LINKING AND ${PACKAGE}_COMP_${OROCOS_TARGET}_LIBRARIES)
      link_libraries( ${${PACKAGE}_LIBRARIES} )
      message("[UseOrocos] Linking all targets with libraries from package '${PACKAGE}'.")
      #message("Linking with ${PACKAGE}: ${${PACKAGE}_LIBRARIES}")
    endif (NOT OROCOS_NO_AUTO_LINKING AND ${PACKAGE}_COMP_${OROCOS_TARGET}_LIBRARIES)

  else (${PACKAGE}_COMP_${OROCOS_TARGET}_FOUND)
    if (VERBOSE)
      message("[UseOrocos] ${PACKAGE} does not provide a .pc file for exporting its build/link flags (or one of it 'Requires' dependencies was not found).")
    endif (VERBOSE)
  endif (${PACKAGE}_COMP_${OROCOS_TARGET}_FOUND)
    
endmacro( orocos_use_package PACKAGE )

macro(_orocos_list_to_string _string _list)
    set(${_string})
    foreach(_item ${_list})
        string(LENGTH "${${_string}}" _len)
        if(${_len} GREATER 0)
          set(${_string} "${${_string}} ${_item}")
        else(${_len} GREATER 0)
          set(${_string} "${_item}")
        endif(${_len} GREATER 0)
    endforeach(_item)
endmacro(_orocos_list_to_string)

macro(orocos_add_compile_flags target)
  set(args ${ARGN})
  separate_arguments(args)
  get_target_property(_flags ${target} COMPILE_FLAGS)
  if(NOT _flags)
    set(_flags ${ARGN})
  else(NOT _flags)
    separate_arguments(_flags)
    list(APPEND _flags "${args}")
  endif(NOT _flags)

  _orocos_list_to_string(_flags_str "${_flags}")
  set_target_properties(${target} PROPERTIES
                        COMPILE_FLAGS "${_flags_str}")
endmacro(orocos_add_compile_flags)

macro(orocos_add_link_flags target)
  set(args ${ARGN})
  separate_arguments(args)
  get_target_property(_flags ${target} LINK_FLAGS)
  if(NOT _flags)
    set(_flags ${ARGN})
  else(NOT _flags)
    separate_arguments(_flags)
    list(APPEND _flags "${args}")
  endif(NOT _flags)

  _orocos_list_to_string(_flags_str "${_flags}")
  set_target_properties(${target} PROPERTIES
                        LINK_FLAGS "${_flags_str}")
endmacro(orocos_add_link_flags)

